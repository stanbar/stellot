/**
 * merkle.ts â€” SHA-256 Merkle tree (mirrors contract merkle.rs)
 *
 * Leaf:     SHA256("stellot:leaf" || leaf_bytes)
 * Internal: SHA256("stellot:node" || left_32 || right_32)
 *
 * Domain separation prevents second-preimage attacks.
 */

import { sha256 } from "@noble/hashes/sha256";
import { concatBytes } from "@noble/hashes/utils";

const LEAF_PREFIX = new TextEncoder().encode("stellot:leaf");
const NODE_PREFIX = new TextEncoder().encode("stellot:node");

export type MerkleProof = Array<{ sibling: Uint8Array; isRight: boolean }>;

export function leafHash(leafBytes: Uint8Array): Uint8Array {
  return sha256(concatBytes(LEAF_PREFIX, leafBytes));
}

function nodeHash(left: Uint8Array, right: Uint8Array): Uint8Array {
  return sha256(concatBytes(NODE_PREFIX, left, right));
}

/**
 * Build a complete binary Merkle tree from leaf values.
 * Pads to the next power of 2 by repeating the last leaf.
 *
 * @param leaves  array of raw leaf bytes (e.g., voter Ed25519 pubkeys)
 * @returns       { root, tree } where tree[i] is the i-th node (BFS order)
 */
export function buildTree(leaves: Uint8Array[]): {
  root: Uint8Array;
  tree: Uint8Array[][];
} {
  if (leaves.length === 0) throw new Error("Empty leaf set");

  // Compute leaf hashes
  let layer = leaves.map(leafHash);

  // Pad to power of 2
  while (layer.length & (layer.length - 1)) {
    layer.push(layer[layer.length - 1]);
  }

  const tree: Uint8Array[][] = [layer];

  while (layer.length > 1) {
    const next: Uint8Array[] = [];
    for (let i = 0; i < layer.length; i += 2) {
      next.push(nodeHash(layer[i], layer[i + 1]));
    }
    tree.push(next);
    layer = next;
  }

  return { root: tree[tree.length - 1][0], tree };
}

/**
 * Generate a Merkle inclusion proof for the leaf at `index`.
 *
 * @param leaves  the original leaf bytes array (same as passed to buildTree)
 * @param index   0-based index of the leaf to prove
 */
export function generateProof(
  leaves: Uint8Array[],
  index: number,
): MerkleProof {
  const { tree } = buildTree(leaves);

  const proof: MerkleProof = [];
  let idx = index;

  for (let level = 0; level < tree.length - 1; level++) {
    const layer = tree[level];
    const isRight = idx % 2 === 0; // sibling is to the right when current is at even index
    const siblingIdx = isRight ? idx + 1 : idx - 1;
    proof.push({ sibling: layer[siblingIdx], isRight });
    idx = Math.floor(idx / 2);
  }

  return proof;
}

/**
 * Verify a Merkle inclusion proof.
 *
 * @param root      expected Merkle root
 * @param leafBytes raw leaf bytes
 * @param proof     generated by generateProof
 */
export function verifyProof(
  root: Uint8Array,
  leafBytes: Uint8Array,
  proof: MerkleProof,
): boolean {
  let current = leafHash(leafBytes);

  for (const { sibling, isRight } of proof) {
    current = isRight
      ? nodeHash(current, sibling)   // sibling is right; current is left
      : nodeHash(sibling, current);  // sibling is left; current is right
  }

  return toHex(current) === toHex(root);
}

function toHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}
